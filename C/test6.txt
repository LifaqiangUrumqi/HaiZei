由多个源文件组成的C程序，经过编辑、预处理、编译、链接等阶段会生成最终的可执行程序。下面哪个阶段可以发现被调用的函数未定义？


A.
预处理
B.
编译
C.
链接
D.
执行
正确答案是 C， 回答正确  收藏 
1.编辑：也就是编写C/C++程序。

2.预处理：相当于根据预处理指令组装新的C/C++程序。经过预处理，会产生一个没有宏定义，没有条件编译指令，没有特殊符号的输出文件，这个文件的含义同原本的文件无异，只是内容上有所不同。

3.编译：将预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后，产生相应的汇编代码文件。

4.链接：通过链接器将一个个目标文件（或许还会有库文件）链接在一起生成一个完整的可执行程序。 链接程序的主要工作就是将有关的目标文件彼此相连接，也就是将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。在此过程中会发现被调用的函数未被定义。

2
2.0分
使用printf函数打印一个double类型的数据，要求：输出为10进制，输出左对齐30个字符，4位精度。以下哪个选项是正确的？


A.
%-30.4e
B.
%4.30e
C.
%-30.4f
D.
%-4.30f
正确答案是 C， 回答正确  收藏 
-： 左对齐

30： 最小字段宽度

.4： 精确度保留小数4位

f： double精度浮点数

e： 科学计数法

3
2.0分
若有定义：int a=7；float x=2.5，y=4.7；则表达式x+a%3*（int）（x+y）%2/4的值是（        ）


A.
2.750000
B.
3.500000
C.
2.500000
D.
0.00000
正确答案是 C， 回答正确  收藏 
首先运算符优先级得知道 乘除  * / % 

然后2.5+7%3*7%2/4=2.5+7%21%1=2.5+0=2.500000

4
3.0分
执行c程序代码“int a=1; int b=0; int c=0; int d=(++a)*(c=1);”,a,b,c,d的值分别为（）。


A.
2，0，1，2
B.
1，0，1，1
C.
2，0，1，1
D.
2，0，0，2
正确答案是 A， 回答正确  收藏 
首先定义int a=1; int b=0; int c=0;，此时a=1,b=0,c=0

int d=(++a)*(c=1);在定义d时，++a使得变为2，后面括号c=1表达式使得c=1

d=2*1=2

注意（c=1)是一个表达式，让c的值为1，而整个（）内的值为真，从而为1.

5
3.0分
语言中哪一种形式声明了一个指向char类型变量的指针p，p的值不可修改，但p指向的变量值可修改？


A.
const char *p
B.
char const *p
C.
char*const p
D.
const char *const p
正确答案是 C， 回答正确  收藏 
const出现在*左边，如const char* p，表示p所指向的变量内容不可变，指针指向可以改变；

const出现在*右边，如char* const p，表示p是个指针常量，即不能指向其他变量，而指向的变量内容可变；

const出现在*左边和右边，如const char* const p，表示p的指向不能改变，指向的变量内容也不能改变。

6
3.0分
以下有关C语言的说法中，错误的是________。


A.
内存泄露一般是指程序申请了一块内存，使用完后，没有及时将这块内存释放，从而导致程序占用大量内存。
B.
可以通过malloc(size_t)函数调用申请超过该机器物理内存大小的内存块。
C.
无法通过内存释放函数free(void*)直接将某块已经使用完的物理内存直接还给操作系统。
D.
可以通过内存分配函数malloc(size_t)直接申请物理内存。
正确答案是 D， 你的答案是 B。你答错了  收藏 
内存泄漏也称作“存储渗漏”，用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。（其实说白了就是该内存空间使用完毕之后未回收）即所谓内存泄漏。
free释放的内存不一定直接还给操作系统，可能要到进程结束才释放。
可以直到malloc不能直接申请物理内存，它申请的是虚拟内存

7
3.0分
一个 C 语言程序在一台 32 位机器上运行。程序中定义了三个变量 x 、 y 和 z ，其中 x 和 z 为 int 型， y 为 short 型。当 x=127 ， y= - 9时，执行赋值语句 z=x+y 后， x 、 y 和 z 的值分别是（） 。


A.
x=0000007FH，y=FFF9H，z=00000076H
B.
x=0000007FH，y=FFF9H，z=FFFF0076H
C.
x=0000007FH，y=FFF7H，z=FFFF0076H
D.
x=0000007FH，y=FFF7H，z=00000076H
正确答案是 D， 你的答案是 C。你答错了  收藏 
C 语言中的整型数据为补码形式， int 为 32 位， short 为 16 位，故 x 、 y 转换成十六进制为 0000007FH 、 FFF7H 。执行 z=x+y 时，由于 x 是 int 型， y 为 short 型，需将短字长数据转换成长字长数据，称之为“符号扩展”。由于 y 的符号位为 1 ，故在 y 的前面添加 16个 1 ，即可将 y 上升为 int 型，其十六进制形式为 FFFFFFF7H 。最后执行加法，即 0000007FH +FFFFFFF7H=00000076H ，其中最高位的进位 1 自然丢弃。故选 D 。

【排除法】 对于 x 的值， 4 个选项都一样，无需计算； z=x+y=127 - 9=118>0 ，前 4 个字节必然全 0 ，排除 BC ；只需算出 y= - 9 的值即可，其十六进制形式为 FFF7H ，排除 A 。

8
2.0分
在使用标准C库时, 下面哪个选项使用只读模式打开文件？


A.
fopen("foo.txt", "r")
B.
fopen("foo.txt", "r+")
C.
fopen("foo.txt", "w")
D.
fopen("foo.txt", "w+")
正确答案是 A， 回答正确  收藏 
r以只读方式打开文件，该文件必须存在。

详细见【C语言标准文档-fopen】

9
3.0分
有以下程序





#include <stdio. h>

int fun( int a ) {

    int b = 0;

    static int c = 3;

    a = ( c + +,b + + );

    return ( a );

}

main( ) {

    int a = 2,i,k;

    for( i = 0;i<2;i + + )

        k = fun( a + + );

    printf("%d\n",k );

}


程序的输出结果是？


A.
4

B.
0

C.
1

D.
2

正确答案是 B， 回答正确  收藏 
题目中fun函数被执行了两次,两次执行后,都是返回了函数内部的b值,所以答案为0,即B选项正确。

fun函数返回的a值和传入的a值无关，每次循环得到的k值和上一次循环也无关，所以直接看最后一次循环结果就好，不过要注意c值和fun()函数的调用次数是有关的。

结果的关键在于逗号表达式 a=(c++,b++); 看了大家的解析，想要提一点，以下两个表达式结果是不同的：

a=(表达式1,表达式2);
a=表达式1,表达式2;
因为逗号运算符在所有运算符中优先级最低，所以表达式（2）实际上执行过程为 (a=表达式1),表达式2; 所以这道题中：

若 a=(c++,b++); 则a=0，因为逗号表达式为(c++,b++)，这个表达式的结果是0，并将这个结果赋值给a；
若 a=c++,b++; 则a=4，因为逗号表达式为(a=c++,b++)，这个表达式结果为0，但赋给a的值是自加前的c值；
下面简单讲下逗号表达式是什么鬼：

逗号表达式的形式就是用逗号运算符将若干个表达式分隔开，形如：

表达式1,表达式2,......,表达式n

它是一个整体，所以上式其实是（表达式1,表达式2,......,表达式n ），运算过程为从左往右逐个表达式计算，整个表达式结果是表达式n的结果。

10
3.0分
在C语言中，char型数据在内存中的表示依据是（）  。


A.
补码
B.
反码
C.
源码
D.
ASCII码
正确答案是 D， 回答正确  收藏 
正型数据：

        在内存中是以补码的形式存在。对于一个正整数来说，它的补码就是它的原码本身。对于一个负整数来说，它的补码为原码取反再加1

实型数据：

        在计算机中也是以二进制的方式存储，关键在于如何将十进制的小数转化为二进制来表示。 
例、12.63 
首先整数部分为：1100 
小数部分：0.63*2=1.26，得小数后第一位为1,0.26*2=0.52得小数的第二位为0，0.52*2=1.04得第三位为1，0.04*2=0.08得第四位为0,0.08*2得第五位，以此类推。于是得到最后的结果为1100.10100001b（省略了后面的计算）

字符型数据：

        把字符的相对应的ASCII放到存储单元中，而这些ASCII代码值在计算机中以二进制的形式存放的。
